<!DOCTYPE html>
<html xml:lang="ja" lang="ja">
<head>
  <title>Auth(test)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <!--link rel="stylesheet" href="style.css"-->
  <style type="text/css"></style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/alasql/4.6.4/alasql.min.js" integrity="sha512-/IeaoBeXScPD3EiZkaYKzjnqRnKJI73FM/18T8P+v2n11hKNCKQmko/n2ccvlDyH3AziR0oPEGShwsZEwO/Jjg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
<p style='text-align:right'>2025/12/20 11:04:04</p>
<h1>SPkey要求テスト</h1>

<button onclick="localFunc()">localFuncテスト</button>

</body>

<script type="text/javascript">
// ライブラリ関数定義
/** devTools: 開発支援関係メソッド集
 * @class
 * @classdesc 開発支援関係メソッド集
 * @prop {string} id=UUIDv4 - 関数・メソッドの識別子
 * @prop {string} whois='' - 関数名またはクラス名.メソッド名
 * @prop {Object.<string, any>} arg={} - 起動時引数。{変数名：値}形式
 * @prop {Object} v={} - 関数・メソッド内汎用変数
 * @prop {string} stepNo=1 - 関数・メソッド内の現在位置
 * @prop {string[]} log=[] - {string[]} 実行順に並べたdev.stepNo
 * @prop {number} start=Date.now() - 開始時刻
 * @prop {number} end - 終了時刻
 * @prop {number} elaps - 所要時間(ミリ秒)
 *
 * - 変更履歴
 *   - rev.3.0.0 : 2025/12/19
 *     - 非同期(平行)処理だとグローバル変数dev内でスタックが混乱、step()で別処理のwhoisを表示
 *       ⇒ グローバル変数内スタックでの呼出・被呼出管理を断念、「関数・メソッド内で完結」に方針転換
 *     - 呼出元との関係(スタック)は断念、標準Errorのstack表示を利用
 *     - クロージャ関数 ⇒ クラス化(∵多重呼出による使用メモリ量増大を抑制)
 *   - rev.2.1.1 : 2025/12/18
 *     - error():ブラウザの開発モードでエラー時message以外が出力されないバグを修正
 *     - end():引数があればダンプ出力を追加
 *   - rev.2.1.0 : 2025/12/12
 *     - ES module対応のため、build.sh作成
 *     - 原本をcore.jsからcore.mjsに変更
 *   - rev.2.0.0 : 2025/12/08
 *     - errorメソッドの戻り値を独自エラーオブジェクトに変更
 *     - functionInfoクラスを導入、詳細情報を追加
 *     - オプションを簡素化、出力モードに統合
 *     - 機能を簡素化
 *       - メソッドから削除：changeOption, check
 *       - dump を step に統合
 *     - stringify -> formatObject
 *   - rev.1.0.1 : 2025/07/17
 *     start/endでメッセージ表示を抑止するため、引数"rt(run time option)"を追加
 *   - rev.1.0.0 : 2025/01/26
 *     SpreadDb.1.2.0 test.jsとして作成していたのを分離
 *
 * @example
 * function xxx(o){
 *   const v = {whois:'xxx',arg:{o},rv:null};
 *   const dev = new devTools(v); // 従来のdev.startを代替
 *   try {
 *     dev.step(1);
 *     ...
 *     dev.end(); // 省略可
 *   } catch(e) {
 *     return dev.error(e);
 *   }
 * }
 *
 */
class devTools {

  /** constructor
   * @constructor
   * @param {Object} v={} - 関数・メソッド内汎用変数
   * @param {Object} opt={}
   * @param {string} opt.mode='dev' - 出力モード
   * @param {boolean} opt.footer=false - 実行結果(start,end,elaps)を出力するならtrue
	 * - 出力モード
	 *   | mode     | エラー | 開始・終了 | dump/step | 用途・備考          |
   *   | :--      | :--:  | :--:     | :--:      | :--               |
	 *   | "none"   | ❌    | ❌        | ❌        | 出力無し(pipe処理等) |
	 *   | "error"  | ⭕    | ❌        | ❌        | エラーのみ出力       |
	 *   | "normal" | ⭕    | ⭕        | ❌        | 本番用              |
	 *   | "dev"    | ⭕    | ⭕        | ⭕        | 開発用              |
   */
  constructor(v={},opt={}){

    // 状態管理変数の初期値設定
		//this.id = self.crypto.randomUUID();
		this.whois = v.whois ?? '';
		this.arg = v.arg ?? {};
    this.v = v ?? {};
		this.stepNo = 1;
		this.log = [];
		this.start = new Date();
		this.end = 0;
		this.elaps = 0;

    // オプションの既定値設定
    this.opt = {
      mode: opt.mode ?? 'dev',
      footer: opt.footer ?? false,
    };

    // 開始ログ出力
    if( this.opt.mode === 'normal' || this.opt.mode === 'dev' ){
      console.log(`${this.toLocale(this.start,'hh:mm:ss.nnn')} ${this.whois} start`);
    }
  }

  /** devToolsError: devTools専用拡張エラークラス */
  static devToolsError(dtObj,...e){
    const rv = new Error(...e);

    // 独自追加項目を個別に設定
    ['whois','arg','stepNo','log','start','end','elaps','v']
    .forEach(x => rv[x] = dtObj[x] ?? null);

    rv.name = 'devToolsError';
    return rv;
  }

  /** step: 関数内の進捗状況管理＋変数のダンプ
   * @param {number|string} label - dev.start〜end内での位置を特定するマーカー
   * @param {any} [val=null] - ダンプ表示する変数
   * @param {boolean} [cond=true] - 特定条件下でのみダンプ表示したい場合の条件
   * @example 123行目でClassNameが"cryptoClient"の場合のみv.hogeを表示
   *   dev.step(99.123,v.hoge,this.ClassName==='cryptoClient');
   *   ※ 99はデバック、0.123は行番号の意で設定
   */
  step(label, val=null, cond=true){
    this.stepNo = String(label);
    this.log.push(this.stepNo);
    // valが指定されていたらステップ名＋JSON表示
    if( this.opt.mode === 'dev' && val && cond ){
      console.log(`== ${this.whois} step.${label} ${this.formatObject(val)}`);
    }
  }

  /** end: 正常終了時処理
   * @param {any} [arg] - 終了時ダンプする変数
   * @returns {void}
   */
  end(arg){
    // 終了時に確定する項目に値設定
    this.finisher();

    // ログ出力
    if( this.opt.mode === 'normal' || this.opt.mode === 'dev' ){
      let msg = `${toLocale(this.end,'hh:mm:ss.nnn')} ${this.whois} normal end`;
      // 引数があればダンプ出力
      if( typeof arg !== 'undefined' ) msg += '\n' + this.formatObject(arg)
      // 大本の呼出元ではstart/end/elaps表示
      if( this.opt.footer ){
        msg += '\n' + `\tstart: ${toLocale(this.start)
        }\n\tend  : ${toLocale(this.end)
        }\n\telaps: ${this.elaps}`;
      }
      console.log(msg);
    }
  }

  error(e){
    // 終了時に確定する項目に値設定
    this.finisher();
    // エラーログ出力時はISO8601拡張形式
    this.start = this.toLocale(this.start);
    this.end = this.toLocale(this.end);

    if( e.name === 'devToolsError' ){
      // 引数がdevToolsError型
      // ⇒ 自関数・メソッドでは無く、呼出先から返されたError
      // ⇒ メッセージを出力せず、そのまま返す
      return e;
    } else {
      // 引数がdevToolsError型ではない
      // ⇒ 自関数・メソッドで発生またはthrowされたError
      // ⇒ メッセージを出力し、devToolsErrorにして情報を付加
      e = devTools.devToolsError(this,e);
      console.error(e.message+'\n'+this.formatObject(e));
      return e;
    }
  }

  /** finisher: end/error共通の終了時処理 */
  finisher(){
    // 終了時に確定する項目に値設定
    this.log = this.log.join(', ');
    this.end = new Date();
    this.elaps = `${this.end - this.start} msec`;
  }

  /** toLocale: ログ出力用時刻文字列整形
   * @param {Date} date - 整形対象Dateオブジェクト
   * @param {string} template - テンプレート
   */
  toLocale(date,template='yyyy-MM-ddThh:mm:ss.nnnZ'){
    const v = {rv:template,dObj:date};
    if( typeof date === 'string' ) return date;

    v.local = { // 地方時ベース
      y: v.dObj.getFullYear(),
      M: v.dObj.getMonth()+1,
      d: v.dObj.getDate(),
      h: v.dObj.getHours(),
      m: v.dObj.getMinutes(),
      s: v.dObj.getSeconds(),
      n: v.dObj.getMilliseconds(),
      Z: Math.abs(v.dObj.getTimezoneOffset())
    }

    // タイムゾーン文字列の作成
    v.local.Z = v.local.Z === 0 ? 'Z'
    : ((v.dObj.getTimezoneOffset() < 0 ? '+' : '-')
    + ('0' + Math.floor(v.local.Z / 60)).slice(-2)
    + ':' + ('0' + (v.local.Z % 60)).slice(-2));

    // 日付文字列作成
    for( v.x in v.local ){
      v.m = v.rv.match(new RegExp(v.x+'+'));
      if( v.m ){
        v.str = v.m[0].length > 1
          ? ('000'+v.local[v.x]).slice(-v.m[0].length)
          : String(v.local[v.x]);
        v.rv = v.rv.replace(v.m[0],v.str);
      }
    }
    return v.rv;
  }

  /** formatObject: オブジェクトの各メンバーを「メンバ名: 値 // データ型」の形式で再帰的に整形する
   * @param {any} obj - 整形対象のオブジェクトまたは配列
   * @param {number} indentLevel - 現在のインデントレベル
   * @returns {string} 整形された文字列
   */
  formatObject(obj, indentLevel = 0) {
    const indent = '  '.repeat(indentLevel); // インデント文字列

    if (obj === null) {
      return `${indent}null // null`;
    }

    const type = typeof obj;

    // プリミティブ型 (number, string, boolean, null, undefined)
    if (type !== 'object' && type !== 'function') {
      // 文字列は二重引用符で囲む
      const value = type === 'string' ? `"${obj}"` : obj;
      return `${indent}${value}, // ${type}`;
    }

    // 関数 (function)
    if (type === 'function') {
      // 関数は文字列化してデータ型を表示しない
      // toLocalISOString の例から、関数の値は引用符なしで表示します
      return `${indent}${obj.toString()},`;
    }

    // オブジェクト型 (Array, Object)

    // Array の場合
    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return `${indent}[ /* Array, length 0 */ ], // object`;
      }

      const elements = obj.map(item =>
        // Arrayの要素は名前がないため、インデントと値のみを返す
        this.formatObject(item, indentLevel + 1)
      ).join('\n');

      // Arrayの要素はカンマではなく改行で区切ります
      return `${indent}[\n${elements}\n${indent}], // Array`;
    }

    // 標準の Object の場合
    const keys = Object.keys(obj);
    if (keys.length === 0) {
      return `${indent}{ /* Object, empty */ }, // object`;
    }

    const members = keys.map(key => {
      const value = obj[key];
      const memberType = typeof value;
      const nextIndent = '  '.repeat(indentLevel + 1);

      // オブジェクト/配列/関数は再帰呼び出し
      if (memberType === 'object' && value !== null || memberType === 'function') {
        // 複合型の場合は、キーと値の開始のみを記載
        const formattedValue = this.formatObject(value, indentLevel + 1);
        return `${nextIndent}${key}:${formattedValue}`;
      }

      // プリミティブ型は一行で表示
      const formattedValue = memberType === 'string' ? `"${value}"` : value;
      return `${nextIndent}${key}:${formattedValue}, // ${memberType}`;
    }).join('\n');

    return `${indent}{\n${members}\n${indent}}`;
  }
}

// authClient関係クラス定義
class authClient {

  static _IndexedDB = null; // データベース接続オブジェクトを格納する静的変数

  /** constructor
   * @constructor
   * @param {authClientConfig} config - authClient設定情報
   */
  constructor(config) {
    const v = {whois:`authClient.constructor`, arg:{config}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1);  // config必須項目のチェック
      if( !config.hasOwnProperty('api') )
        throw new Error(`Required arguments not specified`);

      // -------------------------------------------------------------
      // 設定情報(this.cf)の作成
      // -------------------------------------------------------------
      dev.step(2.1);  // authClient特有の設定項目について既定値を定義
      v.authClientConfig = {
        api: config.api,
        timeout: 300000,
        storeName: 'config',
        dbVersion: 1,
        maxDepth: 10,
      };

      dev.step(2.2); // authClient/Server共通設定値に特有項目を追加
      this.cf = new authConfig(config);
      Object.keys(v.authClientConfig).forEach(x => {
        this.cf[x] = config[x] || v.authClientConfig[x];
      })

      // -------------------------------------------------------------
      dev.step(3);  // その他メンバの値設定
      // -------------------------------------------------------------
      this.idb = {};  // IndexedDBと同期、authClient内で共有

      dev.end(); // 終了処理

    } catch (e) { return dev.error(e); }
  }

  /** _exportIfCryptoKey: CryptoKey型のRSA鍵をIndexedDBに保存可能な文字列に変換
   * @param {string} key - 鍵名。"CPkeySign"等
   * @param {CryptoKey} value - 鍵の内容
   * @returns {string}
   */
  async _exportIfCryptoKey(key, value){
    if( /^(C[SP]key(Sign|Enc))$/.test(key) && value instanceof CryptoKey ){
      return await crypto.subtle.exportKey("jwk", value);
    }
    return value;
  }

  /** _importIfCryptoKey: IndexedDBに保存されたRSA鍵をCryptoKey型に変換
   * @param {string} key - 鍵名。"CPkeySign"等
   * @param {string} value - IndexedDBに保存された鍵の内容
   * @returns {CryptoKey}
   */
  async _importIfCryptoKey(key, value){
    if(!value) return value;

    switch(key){
      case 'CSkeySign':
        return crypto.subtle.importKey(
          "jwk", value, { name:"RSA-PSS", hash:"SHA-256" }, false, ["sign"]
        );
      case 'CPkeySign':
        return crypto.subtle.importKey(
          "jwk", value, { name:"RSA-PSS", hash:"SHA-256" }, false, ["verify"]
        );
      case 'CSkeyEnc':
        return crypto.subtle.importKey(
          "jwk", value, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["decrypt"]
        );
      case 'CPkeyEnc':
        return crypto.subtle.importKey(
          "jwk", value, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["encrypt"]
        );
      default:
        return value;
    }
  }

  /** _withStore: IndexedDB操作共通ラッパ
   * @param {'readonly'|'readwrite'} mode
   * @param {(store: IDBObjectStore)=>Promise<any>} fn
   */
  async _withStore(mode, fn){
    const db = authClient._IndexedDB;
    if (!db) throw new Error("IndexedDB not initialized");

    const tx = db.transaction([this.cf.storeName], mode);
    const store = tx.objectStore(this.cf.storeName);

    const rv = await fn(store);

    await new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
      tx.onabort = () => reject(tx.error);
    });

    return rv;
  }

  /** authRequest: authRequest型のオブジェクトを作成
   * @param {string} func - サーバ側関数名
   * @param {any[]} arg - サーバ側関数に渡す引数
   * @returns {authRequest}
   */
  authRequest(func,arg=[]){
    return {
      memberId: this.idb.memberId,
      deviceId: this.idb.deviceId,
      memberName: this.idb.memberName,
      CPkeySign: this.idb.CPkeySign,
      requestTime: Date.now(),
      func: func,
      arg: arg,
      nonce: crypto.randomUUID(),
    }
  }

  /** exec: ローカル関数の処理要求を処理
   * @param {string} func - サーバ側関数名
   * @param {any[]} arg=[] - サーバ側関数に渡す引数
   * @param {number} depth=0 - 再帰呼出時の階層
   * @returns {any|Error} 処理結果
   */
  async exec(func,arg=[],depth=0) {
    const v = {whois:`${this.constructor.name}.exec`, arg:{func,arg}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1.1);  // 再帰呼出時の階層チェック
      if( depth > this.cf.maxDepth )
        throw new Error('maximum recursion depth exceeded');

      dev.step(1.1); // funcが関数名として有効かチェック
      // なお「::〜::」は内発処理として有効とする
      if( !/^(::[a-zA-Z_$][a-zA-Z0-9_$]*::|[a-zA-Z_$][a-zA-Z0-9_$]*)$/.test(func) ){
        throw new Error('Invalid function');
      }

      dev.step(1.2);  // サーバ側に渡す引数を無毒化
      arg = this.cf.sanitizeArg(arg);

      if( !this.idb.SPkeySign ){  // SPkey未取得

        dev.step(2.1);  // 内発処理「初期情報要求」用のauthRequestを作成
        v.authRequest = this.authRequest('::initial::');

        dev.step(2.2);  // サーバ側に処理依頼
        v.authResponse = this.fetch(v.authRequest);
        if( v.authResponse instanceof Error ) throw v.authResponse;

        dev.step(2.3,v.authResponse); // SPkeySign / deviceId 保存
        v.r = await this.setIndexedDB({
          SPkeySign: v.authResponse.SPkeySign,
          deviceId: v.authResponse.deviceId
        });
        if( v.r instanceof Error ) throw v.r;

        dev.step(2.4);  // 元々の処理要求を再帰呼出
        v.rv = await this.exec(func,arg,depth+1);
        if( v.rv instanceof Error ) throw v.rv;

      } else {  // SPkey取得済

        dev.step(3.1);  // authRequestを作成
        v.authRequest = this.authRequest(func,arg);

        dev.step(3.2);  // サーバ側に処理依頼
        v.authResponse = this.fetch(v.authRequest);
        if( v.authResponse instanceof Error ) throw v.authResponse;

        switch( v.authResponse.status ){
          case 'success': dev.step(3.1);  // サーバ側処理正常終了
            v.rv = v.authResponse.response;
            break;
          case 'CPkey expired': dev.step(3.2);  // CPkey期限切れ
            await this.crypto.generateKeys();
            v.rv = await this.exec('::updateCPkey::');
            if( v.rv instanceof Error ) throw v.rv;
            break;
          case 'login required':  dev.step(3.3);  // 要ログイン(未認証)
            break;
          case 'retry required':  dev.step(3.4);  // パスコード不一致
            break;
          case 'freezing':  dev.step(3.5);  // アカウント凍結中
            break;
          default:  dev.step(3.6);  // その他エラー
            throw v.authResponse.status;
        }
      }

      dev.end();
      return this.idb;

    } catch (e) { return dev.error(e); }
  }

  /** fetch: サーバ側APIの呼び出し
   * @param {authRequest} request - 処理要求
   * @returns {authResponse|Error} 処理結果
   */
  async fetch(request) {
    const v = {whois:`${this.constructor.name}.fetch`, arg:{request}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1);  // authRequestを暗号化
      v.encryptedRequest = await this.crypto.encrypt(request);
      if( v.encryptedRequest instanceof Error ) throw v.encryptedRequest;

      // サーバ側に処理依頼
      dev.step(2.1);  // タイムアウト処理を適用するPromise
      v.timeoutPromise = new Promise((_, reject) => {
        const ms = this.cf.timeout; // タイムアウト時間（ミリ秒）
        const id = setTimeout(() => {
          // 時間内に解決しなければエラーを発生
          reject(new Error(`Fetch timed out after ${ms}ms.`));
        }, ms);
        // 元のPromiseが解決/拒否されたらタイマーを解除するためのCleanup関数
        v.cleanupTimer = () => clearTimeout(id);
      });

      dev.step(2.2);  // fetch処理を行うPromise
      v.fetchPromise = globalThis.fetch(this.cf.api, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(v.encryptedRequest)
      }).then(response => {
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        return response.json();
      });

      dev.step(2.3);  // 競合させて、先に結果が出た方（正常なレスポンスかタイムアウトエラー）を採用
      try {
        v.response = await Promise.race([v.fetchPromise, v.timeoutPromise]);
      } finally {
        v.cleanupTimer(); // タイムアウトタイマーを解除
      }
      if( v.response instanceof Error ) throw v.response;

      dev.step(3);  // 処理結果を復号
      v.rv = this.crypto.decrypt(v.response);
      if( v.rv instanceof Error ) throw v.rv;

      dev.end(); // 終了処理
      return v.rv;

    } catch (e) { return dev.error(e); }
  }

  /** getIndexedDB: IndexedDBの全てのキー・値をオブジェクト形式で取得
   * @param {void}
   * @returns {Object<string,any>} this.idbに格納したIndexedDBの内容({キー:値}形式)
   */
  async getIndexedDB() {
    const v = {whois:`${this.constructor.name}.getIndexedDB`, arg:{}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1);  // IndexedDBに保存された項目を全て配列で取得
      v.raw = await this._withStore('readonly', store =>
        new Promise((resolve, reject) => {
          const req = store.getAll();
          req.onsuccess = () => resolve(req.result);
          req.onerror = e => reject(e.target.error);
        })
      );

      dev.step(2);  // [{key, value}]形式の値配列を{key:value}形式に再構成
      v.rv = {};
      if( Array.isArray(v.raw) && v.raw.length > 0 ){

        dev.step(2.1);  // レコードキーを全て取得
        v.keys = await this._withStore('readonly', store =>
          new Promise((resolve, reject) => {
            const req = store.getAllKeys();
            req.onsuccess = () => resolve(req.result);
            req.onerror = e => reject(e.target.error);
          })
        );

        dev.step(2.2);  // {key:value}形式に再構成
        v.keys.forEach((k, i) => v.rv[k] = v.raw[i]);

        dev.step(2.3);  // CryptoKey復元（存在するものだけ）
        for(const [k,vv] of Object.entries(v.rv)){
          v.rv[k] = await this._importIfCryptoKey(k, vv);
          this.idb[k] = v.rv[k];
        }
      }

      dev.end(); // 終了処理
      return v.rv;

    } catch (e) { return dev.error(e); }
  }

  /** initialize: authClientインスタンス作成
   * - インスタンス作成時に必要な非同期処理をconstructorの代わりに実行
   * - staticではない一般のメンバへの値セットができないため別途constructorを呼び出す
   * @static
   * @param {authClientConfig} config - authClient設定情報
   * @returns {authClient|Error}
   */
  static async initialize(config) {
    const v = {whois:`authClient.initialize`, arg:{config}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1);  // インスタンス生成
      // オプション既定値を先にメンバ変数に格納するため、constructorを先行
      v.rv = new authClient(config);

      dev.step(2);  // DB接続：非同期処理なのでconstructorではなくinitializeで実行
      authClient._IndexedDB = await new Promise((resolve, reject) => {
        if (authClient._IndexedDB) {
          return resolve(authClient._IndexedDB);
        }

        const openRequest = indexedDB.open(v.rv.cf.systemName, v.rv.cf.dbVersion);

        openRequest.onerror = (event) =>
          reject(new Error("IndexedDB接続エラー: " + event.target.error.message));

        openRequest.onsuccess = (event) => {
          authClient._IndexedDB = event.target.result;
          resolve(authClient._IndexedDB);
        };

        openRequest.onupgradeneeded = (event) => {
          const db_upgrade = event.target.result;
          if (!db_upgrade.objectStoreNames.contains(v.rv.cf.storeName)) {
            db_upgrade.createObjectStore(v.rv.cf.storeName);
          }
        };
      });

      dev.step(3);  // IndexedDBの内容を取得
      v.idb = await v.rv.getIndexedDB();
      if( v.idb instanceof Error ) throw v.idb;

      dev.step(4);  // 暗号化・署名検証用インスタンス作成
      v.rv.crypto = new cryptoClient(v.rv.idb,v.rv.cf.RSAbits);

      dev.step(5);  // IndexedDBが空の場合、既定値(初期値)をIndexedDBに保存
      if( Object.keys(v.idb).length === 0 ){

        dev.step(5.1);  // 鍵ペア生成
        v.keys = await v.rv.crypto.generateKeys();
        if( v.keys instanceof Error ) throw v.keys;

        dev.step(5.2);  // CryptoKey以外のauthIndexedDBメンバと合わせて初期値作成
        v.idb = Object.assign(v.keys,{ // IndexedDBの初期値。内容はauthIndexedDB参照
          memberId: 'dummyMemberID',
          memberName: 'dummyMemberName',
          deviceId: 'dummyDeviceID',
          SPkeySign: null,
        });

        dev.step(5.3);  // IndexedDBに格納
        v.r = await v.rv.setIndexedDB(v.idb);
        if( v.r instanceof Error ) throw v.r;

      }

      dev.step(6);  // IndexedDBの内容をメンバ変数に格納
      Object.keys(v.idb).forEach(x => v.rv[x] = v.idb[x]);

      dev.end({IndexedDB:v.rv.idb}); // 終了処理
      return v.rv;

    } catch (e) { return dev.error(e); }
  }

  /** setIndexedDB: IndexedDBの更新(upsert)
   * @param {Object<string, string>} arg
   * @returns {null|Error}
   */
  async setIndexedDB(arg){
    const v = {whois:`${this.constructor.name}.setIndexedDB`, arg:{arg}, rv:null};
    const dev = new devTools(v);
    try {

      await this._withStore('readwrite', async store => {
        for(const [k,val] of Object.entries(arg)){

          const stored = await this._exportIfCryptoKey(k, val);

          this.idb[k] = val;

          await new Promise((resolve, reject) => {
            const req = store.put(stored, k);
            req.onsuccess = () => resolve();
            req.onerror = e => reject(e.target.error);
          });
        }
      });

      dev.end();
      return null;

    } catch(e){ return dev.error(e); }
  }
}
class authConfig {

  /**
   * @constructor
   * @param {authConfig} config - 設定情報(既定値からの変更部分)
   */
  constructor(arg) {
    const v = {whois:`authConfig.constructor`, arg:{arg}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1); // メンバの値設定
      this.systemName = arg.systemName || 'Auth'; // {string} システム名
      if( arg.hasOwnProperty('adminMail') ){
        this.adminMail = arg.adminMail;	// {string} 管理者のメールアドレス
      } else {
        throw new Error('"adminMail" is not specified.');
      }
      if( arg.hasOwnProperty('adminName') ){
        this.adminName = arg.adminName;	// {string} 管理者氏名
      } else {
        throw new Error('"adminName" is not specified.');
      }
      this.allowableTimeDifference = arg.allowableTimeDifference || 120000;
      // {number}	クライアント・サーバ間通信時の許容時差	既定値は2分
      this.RSAbits = arg.RSAbits || 2048;	// {number} 鍵ペアの鍵長
      this.underDev = {};	// {Object} テスト時の設定
      this.underDev.isTest = // {boolean} 開発モードならtrue
      ( arg.hasOwnProperty('underDev')
      && arg.underDev.hasOwnProperty('isTest') )
      ? arg.underDev.isTest : false;

      dev.end(); // 終了処理

    } catch (e) { return dev.error(e); }
  }

  /** sanitizeArg: プリミティブ型のみで構成されるよう無毒化
   * @param {*} value - チェック対象の変数
   * @param {string} path='$' - エラーメッセージ用にオブジェクト内の階層を保持
   * @returns
   */
  sanitizeArg(value, path = '$') {
    if( value === null ||
      typeof value === 'string' ||
      (typeof value === 'number' && Number.isFinite(value)) ||
      typeof value === 'boolean'
    ) return value;

    if (Array.isArray(value)) {
      return value.map((v, i) => this.sanitizeArg(v, `${path}[${i}]`));
    }

    if (typeof value === 'object') {
      // 明示的に禁止したい型
      if (
        value instanceof CryptoKey ||
        value instanceof Date ||
        value instanceof Error ||
        value instanceof Map ||
        value instanceof Set
      ) {
        throw new Error(`Unsupported argument type at ${path}`);
      }

      const obj = {};
      for (const [k, v] of Object.entries(value)) {
        if (typeof v === 'function') {
          throw new Error(`Function not allowed in arg at ${path}.${k}`);
        }
        obj[k] = this.sanitizeArg(v, `${path}.${k}`);
      }
      return obj;
    }

    throw new Error(`Unsupported value type at ${path}`);
  }
}
class cryptoClient {

  /** constructor
   * @constructor
   * @param {authIndexedDB} idb - IndexedDBの内容を保持するauthClientのメンバ変数
   *   CPkeySign, CSkeySign, CPkeyEnc, CSkeyEncはこの下にCryptoKey形式で存在
   * @param {number} RSAbits - RSA鍵長
   */
  constructor(idb,RSAbits) {
    const v = {whois:`cryptoClient.constructor`, arg:{idb,RSAbits}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1); // メンバ変数をセット
      this.idb = idb;
      this.RSAbits = RSAbits;

      dev.end(); // 終了処理

    } catch (e) { return dev.error(e); }
  }

  /** encrypt: 処理要求を暗号化＋署名
   * @param {authRequest} request - 処理要求
   * @returns {encryptedRequest}
   */
  async encrypt(request) {
    const v = { whois: `${this.constructor.name}.encrypt`, arg: { request }, rv: null };
    const dev = new devTools(v);
    try {

      dev.step(1.1);  // encryptedRequestオブジェクト生成関数を定義
      v.makeEncryptedRequest = o => ({
        payload: o.payload ?? null, // payloadとcipherは排他指定
        cipher: o.cipher ?? null,
        iv: o.iv ?? null,
        signature: o.signature, // 指定必須
        encryptedKey: o.encryptedKey ?? null,
        meta: {
          signOnly: o.signOnly ?? false,
          sym: o.sym ?? null,
          rsabits: this.RSAbits,
          keyProvisioning: o.keyProvisioning ?? false
        }
      });

      dev.step(1.2);  // 署名鍵チェック
      if (!(this.idb.CSkeySign instanceof CryptoKey)) {
        throw new Error('CSkeySign is not initialized (not CryptoKey)');
      }

      dev.step(1.3);  // payload UTF-8 化
      v.payloadBytes = new TextEncoder().encode(JSON.stringify(request));

      dev.step(2.1);  // 署名（共通）
      v.signature = await crypto.subtle.sign(
        { name: "RSA-PSS", saltLength: 32 },
        this.idb.CSkeySign,
        v.payloadBytes
      );
      v.signatureB64 = btoa(
        String.fromCharCode(...new Uint8Array(v.signature))
      );

      dev.step(2.2);  // signOnly 自動判定
      v.canEncrypt = this.idb.SPkeyEnc instanceof CryptoKey;
      v.signOnly = !v.canEncrypt;

      dev.step(2.3);  // 鍵配布目的判定
      v.keyProvisioning = v.signOnly && request.func === '::initial::';

      if (v.signOnly) {
        dev.step(3);  // ===== 署名のみ =====
        v.rv = v.makeEncryptedRequest({
          payload: btoa(String.fromCharCode(...v.payloadBytes)),
          signature: v.signatureB64,
          signOnly: true,
          keyProvisioning: v.keyProvisioning
        });

      } else {
        dev.step(4);  // ===== 暗号化＋署名 =====

        dev.step(4.1); // AES鍵生成
        v.aesKey = await crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt"]
        );

        dev.step(4.2); // IV生成
        v.iv = crypto.getRandomValues(new Uint8Array(12));

        dev.step(4.3); // payload暗号化
        v.cipher = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv: v.iv },
          v.aesKey,
          v.payloadBytes
        );

        dev.step(4.4); // AES鍵をRSA-OAEPで暗号化
        v.rawAesKey = await crypto.subtle.exportKey("raw", v.aesKey);
        const encryptedKey = await crypto.subtle.encrypt(
          { name: "RSA-OAEP" },
          this.idb.SPkeyEnc,
          v.rawAesKey
        );

        dev.step(4.5);  // encryptRequestオブジェクト生成
        v.rv = v.makeEncryptedRequest({
          cipher: btoa(String.fromCharCode(...new Uint8Array(v.cipher))),
          iv: btoa(String.fromCharCode(...v.iv)),
          encryptedKey: btoa(String.fromCharCode(...new Uint8Array(encryptedKey))),
          signature: v.signatureB64,
          sym: "AES-256-GCM",
          signOnly: false,
          keyProvisioning: false
        });
      }

      dev.end();
      return v.rv;

    } catch (e) {
      return dev.error(e);
    }
  }

  /** decrypt: 暗号化された処理結果を復号・署名検証
   * @param {encryptedResponse} response - 暗号化されたサーバ側処理結果
   * @returns {authResponse}
   */
  async decrypt(response) {
    const v = {whois:`${this.constructor.name}.decrypt`, arg:{response}, rv:null};
    const dev = new devTools(v);
    try {

      // 1. Base64復元
      const cipher = Uint8Array.from(atob(response.cipher), c => c.charCodeAt(0));
      const encryptedKey = Uint8Array.from(atob(response.encryptedKey), c => c.charCodeAt(0));
      const iv = Uint8Array.from(atob(response.iv), c => c.charCodeAt(0));
      const signature = Uint8Array.from(atob(response.signature), c => c.charCodeAt(0));

      // 2. AES鍵復号
      const rawKey = await crypto.subtle.decrypt(
        { name: "RSA-OAEP" },
        this.idb.CSkeyEnc,
        encryptedKey
      );

      const aesKey = await crypto.subtle.importKey(
        "raw",
        rawKey,
        { name: "AES-GCM" },
        false,
        ["decrypt"]
      );

      // 3. payload復号
      const plain = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        aesKey,
        cipher
      );

      const decoded = JSON.parse(new TextDecoder().decode(plain));

      // 4. 署名検証
      const ok = await crypto.subtle.verify(
        { name: "RSA-PSS", saltLength: 32 },
        this.idb.SPkeySign,
        signature,
        plain
      );

      if (!ok) throw new Error("Signature verification failed");

      v.rv = decoded;
      v.rv.decrypt = "success";

      dev.end(); // 終了処理
      return v.rv;

    } catch (e) { return dev.error(e); }
  }

  /** generateKeys: RSA鍵ペアを生成
   * - 生成のみ、IndexedDBやメンバ変数への格納は行わない
   * @param {void}
   * @returns {Object} 生成された鍵ペア
   */
  async generateKeys() {
    const v = {whois:`${this.constructor.name}.generateKeys`, arg:{}, rv:null};
    const dev = new devTools(v);
    try {

      dev.step(1);  // 署名用
      const signKeys = await crypto.subtle.generateKey({
        name: "RSA-PSS",
        modulusLength: this.RSAbits,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      }, true, ["sign", "verify"]);

      dev.step(2);  // 暗号化用
      const encKeys = await crypto.subtle.generateKey({
        name: "RSA-OAEP",
        modulusLength: this.RSAbits,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      }, true, ["encrypt", "decrypt"]);

      dev.step(3);  // 戻り値作成
      v.rv = {
        CSkeySign: signKeys.privateKey, // CryptoKeyオブジェクト
        CPkeySign: signKeys.publicKey,  // 同上
        CSkeyEnc: encKeys.privateKey,   // 同上
        CPkeyEnc: encKeys.publicKey,    // 同上
        keyGeneratedDateTime: Date.now()
      };

      dev.end(); // 終了処理
      return v.rv;

    } catch (e) { return dev.error(e); }
  }
}

// onLoad, テスト用関数
async function onLoad(){
  const v = {whois:`onLoad`, rv:null};
  const dev = new devTools(v);
  try {

    dev.step(1);  // authClientインスタンス作成
    const auth = await authClient.initialize({
      adminMail: 'ena.kaon@gmail.com',
      adminName: 'あどみ',
      api: 'AKfycbwoI7t1j5YjJgChds6jccBujdboHlBiCPZirNuBqvFRtSot0VtCXMlaLBYm6UgKnU5',
    });

    dev.step(2);  // authインスタンスをグローバル変数と戻り値(テスト用)にセット
    globalThis.auth = auth;
    v.rv = auth;

    dev.end(); // 終了処理
    return v.rv;

  } catch (e) { return dev.error(e); }
}
/** localFunc: テスト用：処理要求発行
 * @param {void}
 * @returns
 */
async function localFunc(){
  const v = { whois: 'localFunc', rv: null};
  const dev = new devTools(v);
  try {

    dev.step(1);  // execテスト
    // サーバ側関数名はsrc/server/code.js「グローバル変数定義」参照
    v.exec = await globalThis.auth.exec('svTest');
    if( v.exec instanceof Error ) throw v.exec;
    dev.step(99.9,v.exec);  // ブラウザ上でのテスト結果確認

    dev.end(); // 終了処理
    return v;

  } catch (e) { return dev.error(e); }
}

// グローバル変数定義
let auth;  // authClient。HTML要素のイベント対応のためグローバル領域で宣言
window.addEventListener('DOMContentLoaded', onLoad());
</script>
</html>
